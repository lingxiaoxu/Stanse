/**
 * Enhanced Company Ranking Service
 *
 * This service integrates with the Python-generated enhanced_company_rankings collection.
 *
 * Data Flow:
 * 1. Try to fetch pre-computed rankings from enhanced_company_rankings (generated by Python every 12h)
 * 2. If not exists or expired (>12h old), fallback to TypeScript real-time calculation
 * 3. TypeScript calculation saves to enhanced_company_rankings (same collection as Python)
 *
 * Collection Structure:
 * - enhanced_company_rankings/{stanceType} - Main document (current ranking)
 * - enhanced_company_rankings/{stanceType}/history/{timestamp} - Historical snapshots
 *
 * Migration from old system:
 * - OLD: company_rankings (deprecated, kept for reference)
 * - NEW: enhanced_company_rankings (used by both Python and TypeScript)
 */

import { db } from './firebase';
import { doc, getDoc, collection, query, orderBy, limit, getDocs } from 'firebase/firestore';
import { StanceType } from '../data/sp500Companies';
import { CompanyRanking, RankedCompany } from './companyRankingCache';
import { rankCompaniesForStanceEnhanced } from './companyRankingService';

const ENHANCED_RANKINGS_COLLECTION = 'enhanced_company_rankings';
const CACHE_DURATION_MS = 12 * 60 * 60 * 1000; // 12 hours

/**
 * Fetch pre-computed ranking from enhanced_company_rankings (Python-generated)
 * Returns null if not exists or expired
 */
export const getEnhancedRankingFromFirebase = async (
  stanceType: StanceType
): Promise<CompanyRanking | null> => {
  try {
    const docRef = doc(db, ENHANCED_RANKINGS_COLLECTION, stanceType);
    const docSnap = await getDoc(docRef);

    if (!docSnap.exists()) {
      console.log(`[Enhanced Rankings] No ranking found for ${stanceType}`);
      return null;
    }

    const data = docSnap.data();

    // Parse dates (handle both Timestamp objects and ISO strings)
    const updatedAt = data.updatedAt?.toDate?.() || new Date(data.updatedAt);
    const expiresAt = data.expiresAt?.toDate?.() || new Date(data.expiresAt);

    // Check if ranking is still valid (not expired)
    const now = new Date();
    if (expiresAt <= now) {
      console.log(`[Enhanced Rankings] Ranking expired for ${stanceType} (expired at ${expiresAt.toISOString()})`);
      return null;
    }

    // Check version (ensure we're reading version 3.0 data)
    if (data.version !== '3.0') {
      console.warn(`[Enhanced Rankings] Old version (${data.version}) found for ${stanceType}, treating as expired`);
      return null;
    }

    console.log(`[Enhanced Rankings] Found valid ranking for ${stanceType} (updated: ${updatedAt.toISOString()}, expires: ${expiresAt.toISOString()})`);

    // Convert Firebase data to CompanyRanking format
    const ranking: CompanyRanking = {
      stanceType: data.stanceType,
      supportCompanies: (data.supportCompanies || []).map((c: any) => ({
        symbol: c.symbol,
        name: c.name,
        sector: c.sector,
        score: c.score,
        reasoning: c.reasoning
      })),
      opposeCompanies: (data.opposeCompanies || []).map((c: any) => ({
        symbol: c.symbol,
        name: c.name,
        sector: c.sector,
        score: c.score,
        reasoning: c.reasoning
      })),
      updatedAt,
      expiresAt
    };

    return ranking;
  } catch (error) {
    console.error(`[Enhanced Rankings] Error fetching ranking for ${stanceType}:`, error);
    return null;
  }
};

/**
 * Get historical rankings for a stance type
 * Returns the most recent N rankings from history subcollection
 */
export const getEnhancedRankingHistory = async (
  stanceType: StanceType,
  limitCount: number = 10
): Promise<CompanyRanking[]> => {
  try {
    const historyRef = collection(db, ENHANCED_RANKINGS_COLLECTION, stanceType, 'history');
    const q = query(historyRef, orderBy('updatedAt', 'desc'), limit(limitCount));
    const querySnapshot = await getDocs(q);

    const history: CompanyRanking[] = [];
    querySnapshot.forEach((doc) => {
      const data = doc.data();
      const updatedAt = data.updatedAt?.toDate?.() || new Date(data.updatedAt);
      const expiresAt = data.expiresAt?.toDate?.() || new Date(data.expiresAt);

      history.push({
        stanceType: data.stanceType,
        supportCompanies: data.supportCompanies || [],
        opposeCompanies: data.opposeCompanies || [],
        updatedAt,
        expiresAt
      });
    });

    console.log(`[Enhanced Rankings] Retrieved ${history.length} historical rankings for ${stanceType}`);
    return history;
  } catch (error) {
    console.error(`[Enhanced Rankings] Error fetching history for ${stanceType}:`, error);
    return [];
  }
};

/**
 * Main entry point: Get enhanced ranking with automatic fallback
 *
 * Logic:
 * 1. Try to fetch from enhanced_company_rankings (Python-generated, every 12h)
 * 2. If not exists or expired, calculate real-time using TypeScript
 * 3. Save TypeScript calculation to same collection (enhanced_company_rankings)
 */
export const getEnhancedCompanyRanking = async (
  stanceType: StanceType,
  forceRefresh: boolean = false
): Promise<CompanyRanking> => {
  console.log(`[Enhanced Rankings] Getting ranking for ${stanceType} (forceRefresh: ${forceRefresh})`);

  // If not forcing refresh, try to fetch from enhanced_company_rankings
  if (!forceRefresh) {
    const cachedRanking = await getEnhancedRankingFromFirebase(stanceType);
    if (cachedRanking) {
      console.log(`[Enhanced Rankings] Using pre-computed ranking from enhanced_company_rankings`);
      return cachedRanking;
    }
  }

  // Fallback: Calculate real-time using TypeScript (AI-Data + LLM mode)
  console.log(`[Enhanced Rankings] No valid pre-computed ranking found, calculating real-time...`);
  const freshRanking = await rankCompaniesForStanceEnhanced(stanceType, forceRefresh);

  console.log(`[Enhanced Rankings] Real-time calculation complete, saved to enhanced_company_rankings`);
  return freshRanking;
};

/**
 * Get company rankings for a user based on their political coordinates
 * This is the main API that components should use
 *
 * Supports dual stanceType system:
 * - If coordinates.coreStanceType exists, use it directly (faster)
 * - Otherwise, calculate from coordinates.economic/social/diplomatic (backward compatible)
 */
export const getEnhancedCompanyRankingsForUser = async (
  economic: number,
  social: number,
  diplomatic: number,
  forceRefresh: boolean = false
): Promise<CompanyRanking> => {
  const { getStanceType } = await import('../data/sp500Companies');
  const stanceType = getStanceType(economic, social, diplomatic);
  return getEnhancedCompanyRanking(stanceType, forceRefresh);
};

/**
 * Get company rankings using PoliticalCoordinates object
 * Optimized version that uses coreStanceType if available
 */
export const getEnhancedCompanyRankingsForCoordinates = async (
  coordinates: any, // Use any to avoid circular import
  forceRefresh: boolean = false
): Promise<CompanyRanking> => {
  // Prefer coreStanceType if available (dual system)
  if (coordinates.coreStanceType) {
    console.log(`[Rankings] Using cached coreStanceType: ${coordinates.coreStanceType}`);
    return getEnhancedCompanyRanking(coordinates.coreStanceType, forceRefresh);
  }

  // Fallback: calculate from coordinates (backward compatible)
  console.log('[Rankings] Calculating stanceType from coordinates (no coreStanceType)');
  const { getStanceType } = await import('../data/sp500Companies');
  const stanceType = getStanceType(
    coordinates.economic,
    coordinates.social,
    coordinates.diplomatic
  );
  return getEnhancedCompanyRanking(stanceType, forceRefresh);
};

/**
 * Check if a ranking exists and is still valid (not expired)
 */
export const isEnhancedRankingValid = async (stanceType: StanceType): Promise<boolean> => {
  try {
    const ranking = await getEnhancedRankingFromFirebase(stanceType);
    return ranking !== null;
  } catch {
    return false;
  }
};

/**
 * Get ranking age in hours
 * Returns null if ranking doesn't exist
 */
export const getEnhancedRankingAge = async (stanceType: StanceType): Promise<number | null> => {
  try {
    const ranking = await getEnhancedRankingFromFirebase(stanceType);
    if (!ranking) return null;

    const ageMs = Date.now() - ranking.updatedAt.getTime();
    return ageMs / (60 * 60 * 1000); // Convert to hours
  } catch {
    return null;
  }
};
